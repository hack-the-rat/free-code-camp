<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="freeCodeCamp Technical Documentation Page project" />
        <title>Games Development Page</title>
        <link rel="icon" href="./fcc.png" type="image/png-icon" />
        <link rel="stylesheet" href="./styles.css" />
    </head>
    <body>
        <nav id="navbar">
            <header>Game Development</header>
            <ul>
                <li>
                    <a href="#Introduction" class="nav-link" rel="internal">Introduction</a>
                </li>
                <li>
                    <a href="#The_HTML5_Game_Platform" class="nav-link" rel="internal">The HTML5 Game Platform</a>
                </li>
                <li>
                    <a href="#Web_technologies_for_Game_Developers" class="nav-link" rel="internal">Web Technologies for Game Developers</a>
                </li>
                <li>
                    <a href="#Anatomy" class="nav-link" rel="internal">Anatomy</a>
                </li>
                <li>
                    <a href="#Examples" class="nav-link" rel="internal">Examples</a>
                </li>
                <li>
                    <a href="#APIs_for_Game_Development" class="nav-link" rel="internal">APIs for Game Development</a>
                </li>
                <li>
                    <a href="#Canvas" class="nav-link" rel="internal">Canvas</a>
                </li>
                <li>
                    <a href="#CSS" class="nav-link" rel="internal">CSS</a>
                </li>
                <li>
                    <a href="#Gamepad_API" class="nav-link" rel="internal">Gamepad API</a>
                </li>
                <li>
                    <a href="#Techniques" class="nav-link" rel="internal">Techniques</a>
                </li>
                <li>
                    <a href="#Using_async_scripts_for_asm.js" class="nav-link" rel="internal">Using async scripts for asm.js</a>
                </li>
                <li>
                    <a href="#Optimizing_Startup_Performance" class="nav-link" rel="internal">Optimizing Startup Performance</a>
                </li>
                <li>
                    <a href="#Using_WebRTC_peer-to-peer_data_channels" class="nav-link" rel="internal">Using WebRTC peer-to-peer data channels</a>
                </li>
                <li>
                    <a href="#Reference" class="nav-link" rel="internal">Reference</a>
                </li>
            </ul>
        </nav>
        <main id="main-doc">
            <section class="main-section" id="Introduction">
                <header>Introduction</header>
                <article>
                    <p>The modern web has quickly become a viable platform not only for creating stunning, high quality games, but also for distributing those games.</p>
                    <p>The range of games that can be created is on par with desktop and native OS counterparts.  With modern Web technologies and a recent browser, it's entirely possible to make stunning, top-notch games for the Web, not just simple card games or multi-player social games that have in the olden days been done using FlashÂ®, but also kick-ass 3D action shooters, RPGs, and more.  Thanks to massive performance improvements in JavaScript, just-in-time (JIT) compiler technology, and new APIs, you can build games that run in the browser (or on HTML5-powered devices like those based on Firefox OS) without making compromises.</p>
                </article>
            </section>
            <section class="main-section" id="The_HTML5_Game_Platform">
                <header>The HTML5 Game Platform</header>
                <article>
                    <p>You can truly think of the Web as a better target platform for your game.  As we like to say, "the Web is the platform."  Let's take a look at the core of the Web platform: </p>
                    <ul>
                        <li>Audio: Web Audio API</li>
                        <li>Graphics: WebGL</li>
                        <li>Input: Touch events, Gamepad API</li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="Web_technologies_for_Game_Developers">
                <header>Web technologies for Game Developers</header>
                <article>
                    <p>For the tech folks, let's dig into the APIs the Web brings to the table that cater to game developers.  Here's a thorough list to give you a taste of what the Web can do for you: </p>
                    <ul>
                        <li>Full Screen API</li>
                        <li>Gamepad API</li>
                        <li>HTML and CSS</li>
                        <li>HTML audio</li>
                        <li>IndexedDB</li>
                        <li>JavaScript</li>
                        <li>Pointer Lock API</li>
                        <li>SVG (Scalable Vector Graphics)</li>
                        <li>Typed Arrays</li>
                        <li>Web Audio API</li>
                        <li>WebGL</li>
                        <li>WebRTC</li>
                        <li>WebSockets</li>
                        <li>Web Workers</li>
                        <li>XMLHttpRequest and File API</li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="Anatomy">
                <header>Anatomy</header>
                <article>
                    <p>Some code needs to be run frame-by-frame, so why attach that function to anything other than the browser's redraw schedule?  On the Web, window.requestAnimationFrame() will be the foundation of most well-programmed per-frame main loops.  A callback function must be passed in to it when it is called.  That callback function will be executed at a suitable time before the next repaint. Here is an example of a simple main loop: </p>
                    <code>
                        window.main = function () {
                            window.requestAnimationFrame( main );
                            
                            // Whatever your main loop needs to do.
                          };
                          
                          main(); //Start the cycle.
                    </code>
                    <p>Select the code in the pad and hit Ctrl+R to watch it unfold in your browser!</p>
                </article>
            </section>
            <section class="main-section" id="Examples">
                <header>Examples</header>
                <article>
                    <ul>
                        <li>Free Demo Games: 
                            <ul>
                                <li>Beloola</li>
                                <li>Tanx</li>
                                <li>Hyper Vanguard Force</li>
                                <li>Swooop</li>
                            </ul>
                        </li>
                        <li>Assorted demos: 
                            <ul>
                                <li>WaveGL</li>
                                <li>Canvas Airport Simulation</li>
                                <li>Animation Physics</li>
                                <li>Volumetric Particle Flow</li>
                            </ul>
                        </li>
                        <li>Commercial games: 
                            <ul>
                                <li>Oort Online</li>
                                <li>A Wizard's Lizard</li>
                                <li>QbQbQb</li>
                                <li>Elliot Quest</li>
                            </ul>
                        </li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="APIs_for_Game_Development">
                <header>APIs for Game Development</header>
                <article>
                    <p>Some of the few APIs are as below: </p>
                    <ul>
                        <li>Canvas</li>
                        <li>CSS</li>
                        <li>Full screen</li>
                        <li>Gamepad</li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="Canvas">
                <header>Canvas</header>
                <article>
                    <p> Mozilla applications gained support for canvas tag starting with Gecko 1.8 (i.e. Firefox 1.5).  The element was originally introduced by Apple for the OS X Dashboard and Safari.  Internet Explorer supports canvas tag from version 9 onwards.  For earlier versions of IE, a page can effectively add support for canvas tag by including a script from Google's Explorer Canvas project.  Google Chrome and Opera 9 also support canvas tag.</p>
                    <p>The canvas element is also used by WebGL to draw hardware-accelerated 3D graphics on web pages.</p>
                    <p>This is just a simple code snippet which uses the CanvasRenderingContext2D.fillRect() method.</p>
                    <h4>HTML</h4>
                    <code>
                        canvas id="canvas" /canvas
                    </code>
                    <h4>JavaScript</h4>
                    <code>
                        var canvas = document.getElementById('canvas');
                        var ctx = canvas.getContext('2d');
                        
                        ctx.fillStyle = 'green';
                        ctx.fillRect(10, 10, 100, 100);
                    </code>
                </article>
            </section>
            <section class="main-section" id="CSS">
                <header>CSS</header>
                <article>
                    <p>CSS is one of the core languages of the open web and is standardized across browsers according to the W3C specification.  Developed in levels, CSS1 is now obsolete, CSS2.1 is a recommendation, and CSS3, now split into smaller modules, is progressing on the standardization track.</p>
                    <p>This module starts with the basics of how CSS works, including selectors and properties, writing CSS rules, applying CSS to HTML, how to specify length, color, and other units in CSS, cascade and inheritance, box model basics, and debugging CSS.</p>
                </article>
            </section>
            <section class="main-section" id="Gamepad_API">
                <header>Gamepad API</header>
                <article>
                    <p>The Gamepad API is a way for developers to access and respond to signals from gamepads and other game controllers in a simple, consistent way.  It contains three interfaces, two events and one specialist function, to respond to gamepads being connected and disconnected, and to access other information about the gamepads themselves, and what buttons and other controls are currently being pressed.</p>
                    <h4>Interfaces</h4> 
                    <p>Gamepad: Represents a gamepad/controller connected to the computer.</p>
                    <p>GamepadButton: Represents a button on one of the connected controllers.</p>
                    <p>GamepadEvent: The event object representing events fired that are related to gamepads.</p>
                    <h4>Experimental Gamepad extensions</h4>
                    <p>GamepadHapticActuator: Represents hardware in the controller designed to provide haptic feedback to the user (if available), most commonly vibration hardware.</p>
                    <p>GamepadPose: Represents the pose of a controller (e.g. position and orientation in 3D space) in the case of a WebVRcontroller.</p>
                    <p>See also the extensions to the Gamepad interface for features that allow you to access the above information.</p>
                    <p>You cannot declare a constant with the same name as a function or variable in the same scope.  For example: </p>
                    <h4>Extensions to other interfaces</h4>
                    <h6>Navigator</h6>
                    <p>Navigator.getGamepads(): An extension to the Navigator object that returns an array of Gamepad objects, one for each connected gamepad.</p>
                    <h6>Window events</h6>
                    <p>Window.ongamepadconnected: Represents an event handler that will run when a gamepad is connected (when the gamepadconnected event fires).</p>
                    <p>Window.ongamepaddisconnected: Represents an event handler that will run when a gamepad is disconnected (when the gamepaddisconnected event fires).</p>
                </article>
            </section>
            <section class="main-section" id="Techniques">
                <header>Techniques</header>
                <article>
                    <p>There are so many techniques and some of them are discussed as below: </p>
                    <ul>
                        <li>Using async scripts for asm.js.</li>
                        <li>Optimizing startup performance.</li>
                        <li>Using WebRTC peer-to-peer data channels.</li>
                        <li>Efficient animation for web games.</li>
                        <li>Audio for Web Games</li>
                        <li>2D collision detection.</li>
                        <li>Tiles and tilemaps overview</li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="Using_async_scripts_for_asm.js">
                <header>Using async scripts for asm.js</header>
                <article>
                    <h3>Putting async into action</h3>
                    <p>Getting async compilation is easy: when writing your JavaScript, just use the async attribute like so: </p>
                    <code>
                        script async src="file.js" /script
                    </code>
                    <p>Or, do the same thing via script: </p>
                    <code>
                        var script = document.createElement('script');
                        script.src = "file.js";
                        document.body.appendChild(script);
                    </code>
                    <h3>When is async not async?</h3>
                    <p>Two common situations in which a script is *not* async (as defined by the HTML spec) are: </p>
                    <code>
                        script async code /script
                    </code>
                    <p>and</p>
                    <code>
                        var script = document.createElement('script');
                        script.innerHTML = "code";
                        ocument.body.appendChild(script);
                    </code>
                    <p>Both are counted as 'inline' scripts and get compiled and then run immediately.</p>
                    <p>What if your code is in a JS string?  Instead of using eval or innerHTML, both of which trigger synchronous compilation, you should use a Blob with an object URL: </p>
                    <code>
                        var blob = new Blob([codeString]);
                        var script = document.createElement('script');
                        var url = URL.createObjectURL(blob);
                        script.onload = script.onerror = function() { URL.revokeObjectURL(url); };
                        script.src = url;
                        document.body.appendChild(script);
                    </code>
                </article>
            </section>
            <section class="main-section" id="Optimizing_Startup_Performance">
                <header>Optimizing Startup performance</header>
                <article>
                    <h3>Starting up nicely</h3>
                    <p>Regardless of platform, it's always a good idea to start up as quickly as possible.  Since that's a universal issue, we won't be focusing on it too much here.  Instead, we're going to look at a more important issue when building Web apps: starting up as asynchronously as possible.  That means not running all your startup code in a single event handler on the app's main thread.</p>
                    <p>Why is it important to be asynchronous?  Other than the reasons suggested above, consider the impact of a non-responsive page or user interface.  The user is unable to cancel if they launch your app by mistake.  If the app is being run in a browser, it's possible the user may get an "unresponsive app" or "slow script" notification.  You should present some kind of interface, such as a progress bar, so that the user knows how much longer they'll need to wait while your app starts up.</p>
                    <h3>Where there's a will...</h3>
                    <p>If you're starting your project from scratch, it's usually pretty easy to just write everything the "right way," making appropriate bits of the code asynchronous.  All pure startup calculations should be performed in background threads, while you keep the run-time of main thread events as short as possible.  Include a progress indicator so the user knows what's going on and how long they'll be waiting.  In theory, anyway, it should be pretty easy to design your new app to start up nicely.</p>
                    <p>While you can use Web workers to run even very large, long-duration chunks of JavaScript code asynchronously, there's a huge caveat that: workers don't have access to WebGL or audio, and they can't send synchronous messages to the main thread, so you can't even proxy those APIs to the main thread.  This all means that unless you can easily pull out the "pure calculation" chunks of your startup process into workers, you'll wind up having to run most or all of your startup code on the main thread.</p>
                    <p>When that part of the document needs to be rendered, load the commented HTML.</p>
                    <code>
                        foo.innerHTML = foo.firstChild.nodeValue;
                    </code>
                </article>
            </section>
            <section class="main-section" id="Using_WebRTC_peer-to-peer_data_channels">
                <header>Using WebRTC peer-to-peer data channels</header>
                <article>
                    <h3>What is a data channel?</h3>
                    <p>A WebRTC data channel lets you send text or binary data over an active connection to a peer.  In the context of a game, this lets players send data to each other, whether text chat or game status information.  Data channels come in two flavors.</p>
                    <p>Reliable channels guarantee that messages you send arrive at the other peer and in the same order in which they're sent.  This is analogous to a TCP socket.</p>
                    <p>Unreliable channels make no such guarantees; messages aren't guaranteed to arrive in any particular order and, in fact, aren't guaranteed to arrive at all.  This is analogous to a UDP socket.</p>
                    <p>We have documentation for using WebRTC.  This article, however, will take advantage of some libraries that can help trivialize the work, and will demonstrate ways to use abstraction to work around implementation differences between browsers.  Hopefully, of course, those differences will fade away in time.</p>
                    <h3>Using the p2p library</h3>
                    <p>One library you can use is the p2p library.  This library provides a simple API for creating peer connections and setting up streams and data channels.  There's also a broker server component and a hosted broker you can use instead of having to set one up for yourself.</p>
                </article>
            </section>
            <section class="main-section" id="Reference">
                <header>Reference</header>
                <article>
                    <ul>
                        <li>
                          All the documentation in this page is taken from this 
                          <a href="https://developer.mozilla.org/en-US/docs/Games" target="_blank">MDN</a>
                          page.  For more information on game development, please remember to visit this webpage before you leave.
                        </li>
                      </ul>
                </article>
            </section>
        </main>
    </body>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</html>