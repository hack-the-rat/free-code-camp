<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Games Development Page</title>
    </head>
    <body>
        <main id="main-doc">
            <section class="main-section" id="Introduction">
                <header>Introduction</header>
                <article>
                    <p>The modern web has quickly become a viable platform not only for creating stunning, high quality games, but also for distributing those games.</p>
                    <p>The range of games that can be created is on par with desktop and native OS counterparts.  With modern Web technologies and a recent browser, it's entirely possible to make stunning, top-notch games for the Web, not just simple card games or multi-player social games that have in the olden days been done using FlashÂ®, but also kick-ass 3D action shooters, RPGs, and more.  Thanks to massive performance improvements in JavaScript, just-in-time (JIT) compiler technology, and new APIs, you can build games that run in the browser (or on HTML5-powered devices like those based on Firefox OS) without making compromises.</p>
                </article>
            </section>
            <section class="main-section" id="The_HTML5_game_platform">
                <header>The HTML5 game platform</header>
                <article>
                    <p>You can truly think of the Web as a better target platform for your game.  As we like to say, "the Web is the platform."  Let's take a look at the core of the Web platform: </p>
                    <ul>
                        <li>Audio: Web Audio API</li>
                        <li>Graphics: WebGL</li>
                        <li>Input: Touch events, Gamepad API</li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="Web_technologies_for_game_developers">
                <header>Web technologies for game developers</header>
                <article>
                    <p>For the tech folks, let's dig into the APIs the Web brings to the table that cater to game developers.  Here's a thorough list to give you a taste of what the Web can do for you: </p>
                    <ul>
                        <li>Full Screen API</li>
                        <li>Gamepad API</li>
                        <li>HTML and CSS</li>
                        <li>HTML audio</li>
                        <li>IndexedDB</li>
                        <li>JavaScript</li>
                        <li>Pointer Lock API</li>
                        <li>SVG (Scalable Vector Graphics)</li>
                        <li>Typed Arrays</li>
                        <li>Web Audio API</li>
                        <li>WebGL</li>
                        <li>WebRTC</li>
                        <li>WebSockets</li>
                        <li>Web Workers</li>
                        <li>XMLHttpRequest and File API</li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="Anatomy">
                <header>Anatomy</header>
                <article>
                    <p>Some code needs to be run frame-by-frame, so why attach that function to anything other than the browser's redraw schedule?  On the Web, <code>window.requestAnimationFrame()</code> will be the foundation of most well-programmed per-frame main loops.  A callback function must be passed in to it when it is called.  That callback function will be executed at a suitable time before the next repaint. Here is an example of a simple main loop:</p>
                    <code>
                        window.main = function () {
                            window.requestAnimationFrame( main );
                            
                            // Whatever your main loop needs to do.
                          };
                          
                          main(); //Start the cycle.
                    </code>
                    <p>Select the code in the pad and hit Ctrl+R to watch it unfold in your browser!</p>
                </article>
            </section>
            <section class="main-section" id="Examples">
                <header>Examples</header>
                <article>
                    <ul>
                        <li>Free Demo Games: 
                            <ul>
                                <li>Beloola</li>
                                <li>Tanx</li>
                                <li>Hyper Vanguard Force</li>
                                <li>Swooop</li>
                            </ul>
                        </li>
                        <li>Assorted demos: 
                            <ul>
                                <li>WaveGL</li>
                                <li>Canvas Airport Simulation</li>
                                <li>Animation Physics</li>
                                <li>Volumetric Particle Flow</li>
                            </ul>
                        </li>
                        <li>Commercial games: 
                            <ul>
                                <li>Oort Online</li>
                                <li>A Wizard's Lizard</li>
                                <li>QbQbQb</li>
                                <li>Elliot Quest</li>
                            </ul>
                        </li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="APIs_for_game_development">
                <header>APIs for game development</header>
                <article>
                    <p>Some of the few APIs are as below: </p>
                    <ul>
                        <li>Canvas</li>
                        <li>CSS</li>
                        <li>Full screen</li>
                        <li>Gamepad</li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="Canvas">
                <header>Canvas</header>
                <article>
                    <p> Mozilla applications gained support for <code>canvas</code> tag starting with Gecko 1.8 (i.e. Firefox 1.5).  The element was originally introduced by Apple for the OS X Dashboard and Safari.  Internet Explorer supports <code>canvas</code> tag from version 9 onwards.  For earlier versions of IE, a page can effectively add support for <code>canvas</code> tag by including a script from Google's Explorer Canvas project.  Google Chrome and Opera 9 also support <code>canvas</code> tag.</p>
                    <p>The canvas element is also used by WebGL to draw hardware-accelerated 3D graphics on web pages.</p>
                    <p>This is just a simple code snippet which uses the <code>CanvasRenderingContext2D.fillRect()</code> method.</p>
                    <p>HTML</p>
                    <code>
                        canvas id="canvas" /canvas
                    </code>
                    <p>JavaScript</p>
                    <code>
                        var canvas = document.getElementById('canvas');
                        var ctx = canvas.getContext('2d');
                        
                        ctx.fillStyle = 'green';
                        ctx.fillRect(10, 10, 100, 100);
                    </code>
                </article>
            </section>
            <section class="main-section" id="CSS">
                <header>CSS</header>
                <article>
                    <p>CSS is one of the core languages of the open web and is standardized across browsers according to the W3C specification.  Developed in levels, CSS1 is now obsolete, CSS2.1 is a recommendation, and CSS3, now split into smaller modules, is progressing on the standardization track.</p>
                    <p>This module starts with the basics of how CSS works, including selectors and properties, writing CSS rules, applying CSS to HTML, how to specify length, color, and other units in CSS, cascade and inheritance, box model basics, and debugging CSS.</p>
                </article>
            </section>
            <section class="main-section" id="Gamepad_API">
                <header>Gamepad API</header>
                <article>
                    <p>The Gamepad API is a way for developers to access and respond to signals from gamepads and other game controllers in a simple, consistent way.  It contains three interfaces, two events and one specialist function, to respond to gamepads being connected and disconnected, and to access other information about the gamepads themselves, and what buttons and other controls are currently being pressed.</p>
                    <h4>Interfaces</h4> 
                    <p>Gamepad: Represents a gamepad/controller connected to the computer.</p>
                    <p>GamepadButton: Represents a button on one of the connected controllers.</p>
                    <p>GamepadEvent: The event object representing events fired that are related to gamepads.</p>
                    <h4>Experimental Gamepad extensions</h4>
                    <p>GamepadHapticActuator: Represents hardware in the controller designed to provide haptic feedback to the user (if available), most commonly vibration hardware.</p>
                    <p>GamepadPose: Represents the pose of a controller (e.g. position and orientation in 3D space) in the case of a WebVRcontroller.</p>
                    <p>See also the extensions to the Gamepad interface for features that allow you to access the above information.</p>
                    <p>You cannot declare a constant with the same name as a function or variable in the same scope.  For example: </p>
                    <h4>Extensions to other interfaces</h4>
                    <p>Navigator</p>
                    <p><code>Navigator.getGamepads()</code>: An extension to the Navigator object that returns an array of Gamepad objects, one for each connected gamepad.</p>
                    <p>Window events</p>
                    <p><code>Window.ongamepadconnected</code>: Represents an event handler that will run when a gamepad is connected (when the gamepadconnected event fires).</p>
                    <p><code>Window.ongamepaddisconnected</code>: Represents an event handler that will run when a gamepad is disconnected (when the gamepaddisconnected event fires).</p>
                </article>
            </section>
            <section class="main-section" id="Techniques">
                <header>Techniques</header>
                <article>
                    <p>There are so many techniques and some of them are discussed as below: </p>
                    <ul>
                        <li>Using async scripts for asm.js.</li>
                        <li>Optimizing startup performance.</li>
                        <li>Using WebRTC peer-to-peer data channels.</li>
                        <li>Efficient animation for web games.</li>
                        <li>Audio for Web Games</li>
                        <li>2D collision detection.</li>
                        <li>Tiles and tilemaps overview</li>
                    </ul>
                </article>
            </section>
            <section class="main-section" id="Using_async_scripts_for_asm.js">
                <header>Using async scripts for asm.js</header>
                <article>
                    <h3>Putting async into action</h3>
                    <p>Getting async compilation is easy: when writing your JavaScript, just use the async attribute like so: </p>
                    <code>
                        script async src="file.js" /script
                    </code>
                    <p>Or, do the same thing via script: </p>
                    <code>
                        var script = document.createElement('script');
                        script.src = "file.js";
                        document.body.appendChild(script);
                    </code>
                    <h3>When is async not async?</h3>
                    <p>Two common situations in which a script is *not* async (as defined by the HTML spec) are: </p>
                    <code>
                        script async code /script
                    </code>
                    <p>and</p>
                    <code>
                        var script = document.createElement('script');
                        script.innerHTML = "code";
                        ocument.body.appendChild(script);
                    </code>
                    <p>Both are counted as 'inline' scripts and get compiled and then run immediately.</p>
                    <p>What if your code is in a JS string?  Instead of using eval or innerHTML, both of which trigger synchronous compilation, you should use a Blob with an object URL: </p>
                    <code>
                        var blob = new Blob([codeString]);
                        var script = document.createElement('script');
                        var url = URL.createObjectURL(blob);
                        script.onload = script.onerror = function() { URL.revokeObjectURL(url); };
                        script.src = url;
                        document.body.appendChild(script);
                    </code>
                </article>
            </section>
            <section class="main-section" id="Optimizing_startup_performance">
                <header>Optimizing startup performance</header>
                <article>
                    <h3>Starting up nicely</h3>
                    <p>Regardless of platform, it's always a good idea to start up as quickly as possible.  Since that's a universal issue, we won't be focusing on it too much here.  Instead, we're going to look at a more important issue when building Web apps: starting up as asynchronously as possible.  That means not running all your startup code in a single event handler on the app's main thread.</p>
                    <p>Why is it important to be asynchronous?  Other than the reasons suggested above, consider the impact of a non-responsive page or user interface.  The user is unable to cancel if they launch your app by mistake.  If the app is being run in a browser, it's possible the user may get an "unresponsive app" or "slow script" notification.  You should present some kind of interface, such as a progress bar, so that the user knows how much longer they'll need to wait while your app starts up.</p>
                    <h3>Where there's a will...</h3>
                    <p>If you're starting your project from scratch, it's usually pretty easy to just write everything the "right way," making appropriate bits of the code asynchronous.  All pure startup calculations should be performed in background threads, while you keep the run-time of main thread events as short as possible.  Include a progress indicator so the user knows what's going on and how long they'll be waiting.  In theory, anyway, it should be pretty easy to design your new app to start up nicely.</p>
                    <p>While you can use Web workers to run even very large, long-duration chunks of JavaScript code asynchronously, there's a huge caveat that: workers don't have access to WebGL or audio, and they can't send synchronous messages to the main thread, so you can't even proxy those APIs to the main thread.  This all means that unless you can easily pull out the "pure calculation" chunks of your startup process into workers, you'll wind up having to run most or all of your startup code on the main thread.</p>
                    <p>When that part of the document needs to be rendered, load the commented HTML.</p>
                    <code>
                        foo.innerHTML = foo.firstChild.nodeValue;
                    </code>
                </article>
            </section>
            <section class="main-section" id="Using_WebRTC_peer-to-peer_data_channels">
                <header>Using WebRTC peer-to-peer data channels</header>
            </section>
            <section class="main-section" id="Reference">
                <header>Reference</header>
            </section>
        </main>
    </body>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</html>